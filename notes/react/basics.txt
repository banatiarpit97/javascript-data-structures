start with react:
npx create-react-app <name-of-app>

updating a parent component re renders all its children because parent needs to
pass the updated props(Even of the props does not change, children will still re render)
i.e. why we use redux and connect the components to store rather than to each other

if a state variable is passed as props to child component and if state variable changes
then props also change automatically in child component

Keep the static content in different component from dynamic content because if they are
in same component then static content will be rendered unnecessarily

components made using pure components can have only props as an arguement
pure functions can have many inner functions
pure functions can not have lifecycle events and their own state.

In react, we dont mutate objects, we create new ones.
Js is fast in replacing objects rather than changing them which gives performance 
improvements

we can not use semicolon when we split the return statement into multiple lines
    return <div>hey</div>;

    return (
        <div>hey</div>
    );

either starting parenthesis or some content should be on the same line as 
return keyword otherwise function would return null.
////////////////////////////////////////////////////////////////////

render root component
    import React from 'react'
    import ReactDOM from 'react-dom'
    import App from './App'

    ReactDOM.render(<App />, document.querySelector("#root"));
////////////////////////////////////////////////////////////////////

we can directly pass an array of html/jsx elements to return statement of render
and it will automatically display it without any map function:
    const imgList = (props) => {
        const images = props.images.map((img) => {
            return <img src={img.url} key={img.id} />
        })

        return <div>{images}</div>      //images is an array here
    }

To efficiently render an array or to prevent react from re-rendering an element from
list again, we need to a 'key' attribute to all the elements of the list.
This key should be uniwue for each element in list.
This key attribute should be present on the root element of the repeating html/jsx template
By giving a key, we tell react to not destroy and create this elem again, instead just rerender/
reposition the elem
////////////////////////////////////////////////////////////////////

append debug_session=logged_in to url to maintain state(if using redux dev tools)
    localhost:3000?debug_session=logged_in

When we will open this link again, all the states, action history etc will be 
maintained as it was
///////////////////////////////////////////////////////////////////
Change without mutation:
    Removing element from an array
    bad -> state.pop()
    good -> state.filter(el => el !== 1)

    Adding element to array
    bad -> state.push(1)
    good -> [...state, 1]

    replacing element in array
    bad -> state[0] = 1
    good -> state.map(el => el === 2?1:2)

    Update prop of object
    bad -> state.name = 'hi'
    good -> {...state, name: 'hi'}

    Adding prop to object
    bad -> state.name = 'hi'
    good -> {...state, name: 'hi'}

    Removing prop from object
    bad -> delete state.name
    good -> {...state, name: undefined}


////////////////////////////////////////////////////////
state initialization(useState) only happens when component is rendered for the first time, after that
whenever component re-renders, previous value of state variable is maintained
////////////////////////////////////////////////////////
if we use a component more than once then all the implementations would have their separate and unique state variables
/////////////////////////////////////////////////////
React strict mode:
import {StrictMode} from 'react';
wrap components inside <StrictMode></StrictMode>
    it will warn us for depreacated features and prevent side effects by
    identifying potential risks in development mode.
    We can choose which components to be wrapped inside strict mode and which not
/////////////////////////////////////////////////////////
we can render html/jsx tags conditionally using props:
    const App = ({tag=React.fragment}) => {
        return (
            <tag>hey</tag>
        )
    }

///////////////////////////////////////////////////////////
<ul>
  {["first", "second"].map((item) => (
    <li>{item}</li>
  ))}
</ul>

That's equivalent to providing a literal array.

<ul>
  {[
    <li>first</li>,
    <li>second</li>,
  ]}
</ul>
////////////////////////////////////////////////////////////

React.Children.only. only allows us to return this.props.children if 
there is only one child. Otherwise, it throws an error.
    render() {
        return React.Children.only(this.props.children)
    }

////////////////////////////////////////////////////////////////////
Child components are rendered before parent components
componentDidMount of child is run before that of parent, its because react renders the components recursively. i.e. React.createComponent('parent', null, React.createComponent('child', null, ...)
and so on.
We can also think of this in a way that parent can only be rendered completely if all its children are rendered and hence children need to rendered before.

But constructor method of parent will always run before the child.and in children, constructor will run in sequential manner i.e. top to bottom
