React.memo
Class components can bail out from rendering when their input props are the same using 
PureComponent or shouldComponentUpdate. Now you can do the same with function components 
by wrapping them in React.memo.

const MyComponent = React.memo(function MyComponent(props) {
  /* only rerenders if props change */
});
////////////////////////////////////////////////////////////////
React.lazy: Code-Splitting with Suspense
Now you can use the Suspense component to do code-splitting by wrapping a dynamic import 
in a call to React.lazy().

import React, {lazy, Suspense} from 'react';
const OtherComponent = lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <OtherComponent />
    </Suspense>
  );
}
/////////////////////////////////////////////////////////////////
static contextType
const MyContext = React.createContext();

class MyClass extends React.Component {
  static contextType = MyContext;
  componentDidMount() {
    let value = this.context;
    /* perform a side-effect at mount using the value of MyContext */
  }
  componentDidUpdate() {
    let value = this.context;
    /* ... */
  }
  componentWillUnmount() {
    let value = this.context;
    /* ... */
  }
  render() {
    let value = this.context;
    /* render something based on the value of MyContext */
  }
}
////////////////////////////////////////////////////////////////////
static getDerivedStateFromError()
React 16 introduced Error Boundaries for handling errors thrown in React renders. 
We already had the componentDidCatch lifecycle method which gets fired after an error 
has already happened. It’s great for logging errors to the server. 
It also lets you show a different UI to the user by calling setState.

Before that is fired, we render null in place of the tree that threw an error. 
This sometimes breaks parent components that don’t expect their refs to be empty. 
It also doesn’t work to recover from errors on the server since the Did lifecycle 
methods don’t fire during server-side rendering.

We’re adding another error method that lets you render the fallback UI before the render completes.
