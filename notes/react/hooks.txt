Hooks allow function components to have state and to respond to 
lifecycle events too, and kind of make class components obsolete. 
They also allow function components to have a good way to handle events.

You can’t use Hooks inside of a class component, but you can definitely mix 
classes and function components with Hooks in a single tree.

Using the useState() API, you can create a new state variable, 
and have a way to alter it. useState() accepts the initial value of 
the state item and returns an array containing the state variable, 
and the function you call to alter the state. Since it returns an 
array we use array destructuring to access each individual item, 
like this: const [count, setCount] = useState(0)

import { useState } from 'react'

You can add as many useState() calls you want, to create as many state 
variables as you want. Just make sure you call it in the top level of 
a component (not in an if or in any other block).
Using hooks, state can be anything - object, array, number, string, bool...
Using useState, state can be shared among components

  const [products, setProducts] = useState([])
  const [userData, setUserData] = useState({name: 'Max', age: 28})
/////////////////////////////////////////////////////////////////////////////

Hooks provide the useEffect() API. The call accepts a function as argument.

The function runs when the component is first rendered, and on every 
subsequent re-render/update. React first updates the DOM, then calls 
any function passed to useEffect(). All without blocking the UI rendering 
even on blocking code, unlike the old componentDidMount and componentDidUpdate, 
which makes our apps feel faster.

const { useEffect } = React

useEffect(() => {
    console.log(`Hi ${name} you clicked ${count} times`)
})

useEffect() can be called multiple times, which is nice to separate unrelated 
logic (something that plagues the class component lifecycle events).

Since the useEffect() functions are run on every subsequent re-render/update, 
we can tell React to skip a run, for performance purposes, by adding a second 
parameter which is an array that contains a list of state variables to watch for. 
React will only re-run the side effect if one of the items in this array changes.

useEffect(
  () => {
    console.log(`Hi ${name} you clicked ${count} times`)
  },
  [name, count]
)

Similarly you can tell React to only execute the side effect once (at mount time), 
by passing an empty array.
Since nothing is provided in array, functin inside useEffect will never execute again
Second arguement always has to be an array
If any of the variable in the array changes, function inside useEffect will be called

Implementing componentWillUnmount:

The function passed as a first argument to useEffect() can return another 
function (or nothing, as we did in the previous examples).

If you return a function, that function will be executed right before the 
function passed to useEffect() runs. It also will be executed before the 
component is removed from the DOM.

Therefore, this returned function is the perfect place for cleanup work. 
Either during every re-render cycle (as written: Right before the “main” 
useEffect() function runs) or before the component disappears.

  useEffect(() => {
    const timer = setTimeout(() => {
      // do something amazing here
    }, 2000)
    return () => {
      // Cleanup work goes in here
      clearTimeout(timer)
    }
  })

If we pass nothing as the second arguement to useEffect, the function inside it
runs repetedly i.e. every sigle time our component re renders

First parameter to the useEffect i.e. a function can not be an async function or a 
function that returns a promise. If we have to the same, we define a async function
separately and call it inside our first params of useEffect
/////////////////////////////////////////////////////////////////////////////////

Before hooks, you either used class components, or you passed an event 
handler using props.

Now we can use the useCallback() built-in API:
const Button = () => {
  const handleClick = useCallback(() => {
    //...do something
  })
  return <button onClick={handleClick} />
}

Any parameter used inside the function must be passed through a second 
parameter to useCallback(), in an array:

const Button = () => {
  let name = '' //... add logic
  const handleClick = useCallback(
    () => {
      //...do something
    },
    [name]
  )
  return <button onClick={handleClick} />
}
/////////////////////////////////////////////////////////////////////////////////
Custom hooks

A hook is just a function that conventionally starts with use. 
It can accept an arbitrary number of arguments, and return anything it wants.

Examples:

const useGetData() {
  //...
  return data
}
or
const useGetUser(username) {
  //...const user = fetch(...)
  //...const userData = ...
  return [user, userData]
}

In your own components, you can use the hook like this:

const MyComponent = () => {
  const data = useGetData()
  const [user, userData] = useGetUser('flavio')
  //...
}
/////////////////////////////////////////////////////////////
From Classes to Hooks

constructor: Function components don’t need a constructor. You can initialize the state 
in the useState call. If computing the initial state is expensive, you can pass a function to useState.

getDerivedStateFromProps: Schedule an update while rendering instead.

shouldComponentUpdate: See React.memo.

render: This is the function component body itself.

componentDidMount, componentDidUpdate, componentWillUnmount: The useEffect Hook can 
express all combinations of these (including less common cases).

componentDidCatch, getSnapshotBeforeUpdate, getDerivedStateFromError: There are no Hook equivalents for these 
methods yet, but they will be added soon.
///////////////////////////////////////////////////////////////
How to share state or logic using hooks
Unlike state in class based components, state using useState can be defined in 
any external file and same goes for useEffect. i.e it is not necessary to use
hooks inside component file

  import {useState, useEffect} from react;
  export const location = () => {
    const [lat, setLat] = useState(0);

    useEffect(async () => {
      const lat = await fetch(url);
      setLat(lat);
    }, [])  //componentDidMount
  }

Now import this function inside component file and call this function inside the
functional component.(IT NEEDS TO BE CALLED INSIDE THE FUNCTION ONLY) and we will have
the shared state and logic
///////////////////////////////////////////////////////////////////