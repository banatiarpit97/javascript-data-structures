var xhttp = new XMLHttpRequest();

xhttp.open("GET", "filename", true);        //open the connection
xhttp.send();                               //send the request

xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
       document.getElementById("demo").innerHTML = xhttp.responseText;
    }
};
////////////////////////////////////////////////////////////////////////////
fetch returns a promise.
The Promise returned from fetch() wonâ€™t reject on HTTP error status even if the response
is an HTTP 404 or 500. Instead, it will resolve normally (with ok status set to false),
and it will only reject on network failure or if anything prevented the request from completing.

By default, fetch won't send or receive any cookies from the server,
resulting in unauthenticated requests if the site relies on maintaining a user
session(to send cookies, the credentials init option must be set).

fetch(url, {
    method: "POST", // *GET, POST, PUT, DELETE, etc.
    mode: "cors", // no-cors, cors, *same-origin
    cache: "no-cache", // *default, no-cache, reload, force-cache, only-if-cached
    credentials: "same-origin", // include, *same-origin, omit
    headers: {
        "Content-Type": "application/json; charset=utf-8",
        // "Content-Type": "application/x-www-form-urlencoded",
    },
    redirect: "follow", // manual, *follow, error
    referrer: "no-referrer", // no-referrer, *client
    body: JSON.stringify(data), // body data type must match "Content-Type" header
}).then((res) => {
    console.log(res.json());
})

FORM DATA:
var formData = new FormData();
var fileField = document.querySelector("input[type='file']");

formData.append('username', 'abc123');
formData.append('avatar', fileField.files[0]);

HEADERS:
var myHeaders = new Headers();
myHeaders.append("Content-Type", "text/plain");
myHeaders.append("Content-Length", content.length.toString());
myHeaders.append("X-Custom-Header", "ProcessThisImmediately");
////////////////////////////////////////////////////////////////////////////
CALLBACKS :(function to be executed when a certain task is done)
A callback is simply a function that is passed to another function as a parameter
and is invoked or executed inside the other function. 

setTimeout(cb, 1000);   //'setTimeout' is async code, 'while' is synchronus

there are 2 problems with callbacks:
    1. callback hell - when there are nested callbacks i.e. a callback function to be executed when
        previous callback function is done and so on.
        setTimeout(function(){      
            console.log(1);
            setTimeout(function(){
                console.log(2);
                setTimeout(function(){
                  console.log(3);
                })
            })  
        })
    2. inversion of control - We pass our callback function to the request and give control to the api
        that when you are done, call the callback function.Now api will have the power to call the
        callback any number of time, whenever it wants, with whatever context, params...(too much power
        to a third party api)
////////////////////////////////////////////////////////////////////////////

Generators(yield) :(making our synchronus looking code async)
 function* gen(){           //Generator function(with a *)
     console.log("hello");
     yield null;            //execution will stop here
     console.log("world");
 }
 var it = gen();    //return an iterator
 it.next();     //prints hello
 (will start executing from prev yield or start of function to next yield or end of function)
 it.next();     //prints world

 yield statement can be used to pass params 'from and to' to Generator function
 yield pauses the Generator function and next() resumes the execution.

 Using Generators and promises together - Generators yielding out promises and when promise completes
 automatically restarting the Generator.
 No need to use this as async-await functions are implementation of this and promises
 which is very easy to use 
////////////////////////////////////////////////////////////////////////////

PROMISES :
We can call a function that would take some time to execute, we then subscribe to its continuation.

This solves the inversion of control problem of callbacks.
In this, we don't provide api our callback function, instead the api returns a promise
based on which we continue our code.

var promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});

promise1.then((value) => {
  console.log(value);       //foo
});

There are 3 states of promise :
1.Pending
2.Fulfilled
3.Rejected

Methods on prototype of Promise:
1. then()       //called when promise is Fulfilled
2. catch()      //called when promise is rejected
3. finally()    //called when promise is Fulfilled or rejected
all the above 3 also returns a promise, Hence promises can be chained i.e. then after then...

Methods on Promise:
1. Promise.all(iterable)
2. Promise.race(iterable)
3. Promise.resolve(value)
4. Promise.reject(reason)

Create a function that returns a promise(i.e. a function that executed async code):
getUser(){
    return new Promise((resolve, reject) => {   
      this.storage.get('user').then(user => {
        if (user) {
          resolve(user);
        }
        else{
            reject('login');
            }
      });
    })  
  }
now we call this function as:
getUser().then(
    (response) => {
        console.log(response)
        }
    ).catch((err) => {
        console.log(err)
    })

As we can see promise also uses callback function(Promises are structured callbacks)
but it is still better than callbacks

chaining of promises :
    pr.then((res) => {
        console.log(res)
        return new Promise((resolve, reject) => {resolve(5)})
    },(err) => {
        console.log(err)
    })
    .then((res) => {
        console.log(res)
        return new Promise((resolve, reject) => {resolve(5)})
    },(err) => {
        console.log(err)
    })

    instead of having a error handler for each then, we can have a catch block after all
    then that will catch any errors before it.
    pr.then((res) => {
        console.log(res)
        return new Promise((resolve, reject) => {resolve(5)})
    })
    .then((res) => {
        console.log(res)
        return new Promise((resolve, reject) => {resolve(5)})
    })
    .catch((err) => {
        console.log(err)
    })

If we have more than 1 promise, we want to wait for, we use Promise.all
    var p1 = getStudentById(10);
    var p2 = getStudentById(102);
    var p3 = getStudentById(103);

    Promise.all([p1, p2, p3]).then(function(students) {
        console.log("All the students are here: " + students);
    });
////////////////////////////////////////////////////////////////////////////

ASYNC-AWAIT functions(uses implicit promises):

async function asyncCall() {        //now this function will behave as async
  console.log('calling');
  var result = await resolveAfter2Seconds();
  //or var result = await fetch("url");
  console.log(result);      //resolved
  //will not be executed until 'resolveAfter2Seconds' has returned a promise
}

An async function can contain an await expression that pauses the execution of the async function
and waits for the passed Promise's resolution, and then resumes the async function's execution
and returns the resolved value.

Remember, the await keyword is only valid inside async functions. 
If you use it outside of an async function's body, you will get a SyntaxError.
////////////////////////////////////////////////////////////////////////////

PROMISES VS OBSERVABLES :
1. promises have methods like resolve()
   observables have methods like observer.next()

2. when promise in fulfilles - .then()
   when observable in fulfilles - .subscribe()

create a promise:
    const pr = new Promise((resolve, reject) => {
        resolve(5)
    })
    pr.then((value) => {console.log(value)})

create a observable:
    const obs = new Observable((observer) => {
        observer.next(5)
    })
    obs.subscribe((value)=>{console.log(value)})

3. We can resolve a promise only once
        the first resolve statement will be executed and after that all resolve statements will
        be ignored.Only one of the resolve or reject can executed.

   We can emit multiple values from an observable
        const obs = new Observable((observer) => {
                observer.next(5)
                observer.next(6)
                observer.complete()     //after this we can not call next()
            })

4. Promise constructor immediately calls function passed to it.
        (even when no one is listening to the changes)
        const pr = new Promise((resolve, reject) => {
            resolve(5)               //will start executing right away, even before pr.then is executed
        })
        pr.then((value) => {console.log(value)})

   Function passed to Observable constructor gets called only when someone actually
   subscribes to an Observable()
        const obs = new Observable((observer) => {
            observer.next(5)        //will not start executing right away,
        })
        obs.subscribe((value)=>{console.log(value)})
        //now the above function will start executing because someone has subscribed to it

    i.e. Promises are eager, observables are lazy.

5. Promises can not be cancelled 
   but we can unsubscribe an observable when we no longer need to listen to it.
   const obs = new Observable((observer) => {
            observer.next(5)        //will not start executing right away,
        })
   const subs = obs.subscribe((value)=>{console.log(value)})
   //subscribe method returns a subscriptions and not an observable.
   subs.unsubscribe();

6. Promises can be chained very easily by chaining .then methods
    observables can not be so easily chained as .subscribe return subscription instead of Observable
    we chain observables using operators

7. Promises are multicast whereas observables are unicast by default but can be made multicast also
    Because Promises are eager, function passed to Promise constructor is called 
    only when Promise is created and never again.
    So even if there are more than 1 one listeners for a promise, they would receive the same result
    and at the same time.

    In observables, every subscriber has its own copy of observable(kind of) and whenever someone
    subscribes, observable is starts executing from the start.
    To make observable multicast(use the share method) :
    
    const sharedWaitOneSecondObservable = obs.share();

    sharedWaitOneSecondObservable.subscribe(doSomething);
    sharedWaitOneSecondObservable.subscribe(doSomethingElse);

    Multicast(promises) works good for HTTP results where we don't want double request
    Unicast(Observables) works good for deferring some action
        const waitOneSecondPromise = new Promise((resolve) => {
            setTimeout(() => resolve(), 1000);
        });
    //this will not work as setTimeout will be fired as soon as it is created(even before someone listens
    to it and the listeners after the fist one will be fired immediately because only one copy is present)