javascript is prototype based language.
Most languages like c++, java have class-based inheritance.
Javascript has prototype-based inheritance.

Every js object(function, object..) has a prototype from which it inherits properties and methods.
The prototype is also an object and hence inherits from another prototype and so on.this is prototype chain.
At the top of properties chain is Object.prototype which is initialised when a js program starts
executing.This prototype has methods like sort(), toString() etc.
Object.prototype inherits from null.(i.e. prototype of Object.prototype is null)

every JavaScript function has a prototype property (this property is empty by default)
This prototype property is not enumerable; that is, it isn’t accessible in a for/in loop but can accessed
by __proto__
The second concept with prototype in JavaScript is the prototype attribute. 
Think of the prototype attribute as a characteristic of the object; this characteristic tells us
the object’s “parent”. In simple terms: An object’s prototype attribute points to the 
object’s “parent”—the object it inherited its properties from. The prototype attribute is 
normally referred to as the prototype object, and it is set automatically when you create a new object.
To expound on this: Every object inherits properties from some other object, 
and it is this other object that is the object’s prototype attribute or “parent.” 
This prototype attribute can be accesses using __proto__
So, when a function is created, a new prototype is made and is empty by default
When we create an object, no new prototype is created, the object is just linked to already present
prototype from which it inherits properties.
all objects that inherit from another object also inherit a constructor property. 
And this constructor property is simply a property (like any variable) that holds or 
points to the constructor of the object.

If an object is created with an object literal (var newObj = {}), it inherits properties 
from Object.prototype and we say its prototype object (or prototype attribute) 
is Object.prototype(constructor of created object is Object())
An object created with new Fruit () will have Fruit.prototype as its prototype and constructor
of object created is Fruit();


So prototype is just an object that contains properties and methods that the object it is bounded
to can have.An object has properties and methods equal to properties and methods present in the
object itself and what it inherits from its prototype and what its prototype inherits from parent
prototype and so on.
When we invoke property/method from an object, javascript first searches it in the object itself and
if not found, it tries searching in its prototype and then its prototype's property....
so prototype chain works like scope chain

THERE CAN BE ONLY ONE PROTOTYPE CHAIN, i.e. NO MULTIPLE INHERITANCE

constructor functions are used to create prototypes
//////////////////////////////////////////////////////////////////////////////////////////////
new Array():    //built in
Array -> Array.prototype -> Object.prototype -> null

new Food();     //not built in
Food -> Food.prototype -> Object.prototype -> null

All built-in constructors (Array (), Number (), String (), etc.) were created from the 
Object constructor, and as such their prototype is Object.prototype.
//////////////////////////////////////////////////////////////////////////////////////////////
Manipulating prototype of newly created constructor functions

function food(name, color, weight){
    this.name = name;                   //1st method of adding props
    this.color = color;
    this.weight = weight;
}
food.prototype.details = function(){    //2nd method of adding props
        return `${this.name} is of ${this.color} color`;
}
//this adds details method to food's prototype, which means that every food object will have access
to details method.
We should add methods to prototype instead of directly adding it to constructor function.
If we define methods in constructor function, then it will be created every time a new object is created.
Whereas if we define them in prototype, method are not created every time, instead they are just inherited.
This causes big performance issues.
So, the properties should be defined in constructor function using 'this' keyword because it has to
be unique for every object and should be created every time an object is created whereas functions/methods
should be placed inside prototypes because we don;t want them to be vreated every time but it should
be inherited by each object.

object_name.hasOwnPropert(prop_name) -> return true if prop is defined in object, return false if prop
is defined in its prototype or any other parent prototype
//////////////////////////////////////////////////////////////////////////////////////////////

Manipulating prototype of built in objects
Array.prototype.midElem = function(){
    return this[this.length/2];
}

now every array created will have this midElem method
Though it is not a good practice to do this, instead we should use a separate function for this
It is used when we want older versions of js to have new functions(backward compatibility)
//////////////////////////////////////////////////////////////////////////////////////////////

Extending the prototype chain :

function circle(radius){
    this.radius = radius;
}
circle.prototype.diameter = function(){
    return this.radius*2;
}

function semicircle(radius){
    Circle.call(this, radius);
    //call is used to access property or method of another object but with context of current one.
}
semicircle.prototype = Object.create(circle.prototype); 
//now semicircle inherits from prototype of circle i.e. we made semicircle a child of circle.[inheritance]
semicircle.property.constructor;  //will give circle which is a problem
semicircle.property.constructor = semicircle  //to solve the above problem

var sc = new semicircle(15);
Object.getPrototypeOf(sc) -> will give cirle
Now semicircle will have access to radius and diameter

can also be done using(without new keyword, though no difference in working or behaviour) :

var circle = {
    init:function(radius){      //behaves like constructor
        this.radius = radius;
    },
    diamater:function(){
        return this.radius*2;
    }
}
var semicircle = Object.create(circle);
semicircle.area = function(){
    return 3.14*this.radius*this.radius;
}

var s1 = Object.create(semicircle);
s1.init(3);
s1.area();
//////////////////////////////////////////////////////////////////////////////////////////////

Using class keywords to extend prototype chain :

class circle{
    constructor(radius){
        this.radius = radius;
    }

    diameter(){
        return this.radius*2;
    }
}

class semicircle{
    constructor(radius){
        super(radius)   //call constructor of parent class
    }
}
var sc = new semicircle(15);
sc.diameter()   //diamter fucntion is available as its parent class has this method.
//////////////////////////////////////////////////////////////////////////////////////////////

__proto__ -> Dunder proto(ES6)
gets the internal prototype linkage i.e. [[Prototype]]
Dunder proto only exist on the Object.prototype(topmost prototype in chain)
this can also be retrieved using Object.getPrototypeOf(obj);
//////////////////////////////////////////////////////////////////////////////////////////////

If we define a function in object with a name that is already present in its above prototype chain
then instead of overriding already exiting method/prop, it creates a new one in the object and
from now on it will access the method present in it and not its prototype chain.
To still access the method/prop in its above chain from object's context, we do :
constructor_function_name.prototype.method_name.call(obj);
//////////////////////////////////////////////////////////////////////////////////////////////
 
while going above the prototype chain, 'this' does not change, 
it still remains what it was when first assigned
//////////////////////////////////////////////////////////////////////////////////////////////

ways to add methods to prototype:
    1.  Circle.prototype.diameter = function(){
            return this.radius*2;
        }
    2.  Circle.prototype = {
            constructor : Circle,
            diameter : function(){
                return this.radius*2;
            }
        }

    in first one, we are adding methods to prototype
    whereas in second one, we are completely overriding the prototype object i.e. already existing
    methods on prototype will be deleted.
    disadvantage of overwriting the prototype is that the constructor property no longer points
    to the prototype, so we have to set it manually.
//////////////////////////////////////////////////////////////////////////////////////////////

    Object.create = function (o) {
        //It creates a temporary constructor F()
    function F() { }
        //And set the prototype of the this constructor to the parametric (passed-in) o object
        //so that the F() constructor now inherits all the properties and methods of o
    F.prototype = o;

        //Then it returns a new, empty object (an instance of F())
        //Note that this instance of F inherits from the passed-in (parametric object) o object. 
        //Or you can say it copied all of the o object's properties and methods
    return new F();
    }

    So Object.create is the way to use inheritance in js.

//////////////////////////////////////////////////////////////////////////////////////////////
Everything inside the constructor function that is defined without 'this' keyword is a private 
property and can not be accessed from outside or even from its object.
//////////////////////////////////////////////////////////////////////////////////////////////
properties of constructor function can not be accessed without creating an object
    function obj (age){
        this.age = 21;
        yoyo = "banati";    //private property
    }
    var a = new obj(21);

    console.log(obj.yoyo, obj.age);     //undefined, undefined
    console.log(a.yoyo, a.age);     //undefined, 21

//////////////////////////////////////////////////////////////////////////////////////////////
