Creating objects : 

var a = { }  or 

var a =  new Object(); then a.prop = value;

////////////////////////////////////////////////////////////////////////////

Objects can also contain functions :

var a = {
    prop: "string",
    name : function(){
        return this.prop;
    }
    age : function(n){
        return n;
    }
}
a.name();       //parenthesis to call the function
a.age(21);

////////////////////////////////////////////////////////////////////////////

We can add properties/functions to objects dynamically:
a.new1 = "hello"
a.new2 = function(){return a};

////////////////////////////////////////////////////////////////////////////

Accessing properties :

a.name or 
a["name"]   

Second one has an advantage that we can use dynamic variables that hold property names:
var w = "name";
a[w] -> will calculate a["name"];

////////////////////////////////////////////////////////////////////////////

Objects are passed by refernce :
var a = {name: "arpit"};
var b = a;
b.name = "yoyo";
a.name -> will give "yoyo"

to create copy of objects and not aliases :
var b = Object.create(a);

////////////////////////////////////////////////////////////////////////////

Everything in js is objects like int, string, etc thats why we can invoke functions using '.' notation
string.length, string.toUppercase() etc

////////////////////////////////////////////////////////////////////////////
Object destructuring in ES6
to create new variables from properties of existing objects

var user = {
    name:"arpit",
    age:21
}

var {name} = user;
console.log(name)   //prints arpit
////////////////////////////////////////////////////////////////////////////

in ES6, if name and value of property of object is same, we can emit colon and property

var text = "hello"

var obj = {text:text}
is same as
var obj = {text}
////////////////////////////////////////////////////////////////////////////

Property names can be a string or a number, but if the property name is a number,
it has to be accessed with the bracket notation.

var ageGroup = {30: "Children", 100:"Very Old"};
console.log(ageGroup.30) // This will throw an error
console.log(ageGroup["30"]); // Children
////////////////////////////////////////////////////////////////////////////
only objects and arrays are passed as refernce, number, string, booleans are passed by value
////////////////////////////////////////////////////////////////////////////

Each data property (object property that store data) has not only the name-value pair,
but also 3 attributes (the three attributes are set to true by default):
— Configurable Attribute: Specifies whether the property can be deleted or changed.
— Enumerable: Specifies whether the property can be returned in a for/in loop.
— Writable: Specifies whether the property can be changed.
////////////////////////////////////////////////////////////////////////////

While you can use some reserved word such as “for” as property names in your objects,
it is wise to avoid this altogether.
////////////////////////////////////////////////////////////////////////////

console.log(prop in object)     //return true if prop exist in object or is inherited from any of prototype
console.log(object.hasOwnProperty('prop'))  //return true only if prop exists on object itself     
                            //will return false if inherited

////////////////////////////////////////////////////////////////////////////
for-in loop iterates over all enumerable properties(own and inherited)
but properties inherited from Object.prototype are not Enumerable
////////////////////////////////////////////////////////////////////////////
To delete a property from an object, you use the delete operator. 
Only properties that are defined in object itself and that defined in constructor function using this
keyword can be deleted.(Props in constructor function are not inherited, they are created every time
we create an object but props defined in proto are inherited)
You cannot delete properties that were inherited(Defined in proto), nor can you delete properties with their
attributes set to configurable. You must delete the inherited properties on the prototype object 
(where the properties were defined). Also, you cannot delete properties of the global object, 
which were declared with the var keyword.

delete obj.prop;        //always returns true(whether prop deleted or not)

////////////////////////////////////////////////////////////////////////////
Borrowing methods from objects:

    var first = {
        scores  :[20, 34, 55, 46, 77],
        avgScore:null,
    }

    var second = {
        scores  :[900, 845, 809, 950],
        avgScore:null,
        avg :function () {
            var sum;
            this.scores.forEach((elem) => {
                sum +=elem;
            });
            this.avgScore = sum/this.scores.length;
        }
    }
    first.avgScore = second.avg();
    //if we borrow method like above, 'this' will refer to 'second'

    to correct -> first.avgScore = second.avg().bind(first);