function declaration :

    function name(){ }
    we can nest functions inside function:
        function name(){
            function class(){ }
        }
    

function expression :
    var name = function(){ }        //anonymous function expression
    var name = function hi(){ }     //named function expression
    //can give name to functions
    //still can not call function using 'hi', have to call using 'name' only
    //we should always use named function expression instead of anonymous function expression
    //because it would let us perform recursion
    //and it help in debugging -> instead of giving error for anonymous function, it would give name of function

arrow function :
    var name = (firstname) => { return "hello"+name;}

    if ony 1 params -> no need of parenthesis(if 0 params, then required)
    if only 1 statement in function definition, no need of return statement and curly braces

    var name = firstname => "hello"+name

    downside of arrow functions :
        1. Arrow functions does not have a this binding, if it is used inside a global object, 
        then it would have a this equal to global.
            var user = {
                name:"arpit",
                hi: () => {
                    console.log('hi', this.name);
                }
                function hi1(){
                    console.log('hi', this.name);
                }
            }
            user.hi();      //prints hi undefined
            user.hi1();      //prints hi arpit
        2. Does not have 'arguements' object of its own, takes it from the global or outer function

IIFE:
    (function(){       //These are functions that are called immediately but can not be called again

    })();
    
    (function(a,b){    //passing arguements to iife

    })('a', 'b');

the basic idea behind iife is to separate the function from global
scope so that it could not be called from outside that function.
iife can be named (function iife(){})();

we can wrap the calling parenthesis also in top level parenthesis like
(
    function iife()
    {}()
)
the wrapping parenthesis are to help the compiler to parse this correctly and also to escape this
function from global scope.
We can not call an iife from anywhere else.
But iife has access to global variables and functions.

Using new :
    var name = new Function("console.log('hh)");
    name();

1. funtion expressions and arrow functions are not hoisted unlike declaration

2. function declaration can become function expression if declaration
is neither top level nor inside other functions.
    if(a>5){
        function name() { }   -> will be treated as expression
    }

    function name(){
        function class(){ }   -> will be treated as declaration
    }

3. Every function has an object called 'arguements' which is like an array of parameters passed.

4. Spread operator :
        extra arguements can be accomodated by spread operator(needs to be last parameter)
        function spread(a, b, ...c){
            console.log(c);     //will print an array -> [3,4,5,6];
        }
        spread(1,2,3,4,5,6);

5. We can pass less, equal or more arguements to a function than actuaaly required
    no error will be shown.

6. Function can be passed as parameters and can be executed there
    function foo(){
        var bar = "bar";
        function baz(){
            console.log(bar);
        }
        bam(baz);       //passing function as parameter
    }
    function bam(baz){
        baz();          //executing the passed function
        //prints bar
    }
    foo();

7. if we want to return more than 1 thing from a function, put those things in an array or object
    and then return that array/object.

8. Functions are treated as objects only :
    function name(first){
        this.firstname = first;
    }
    name.lastname = null;       //can dynamically add properties to functions

9. Higher order functions are functions that either take other function as params or return other functions
    function mapForEach(arr, fn) {              //receive function's name(without parenthesis)
        const newArray = [];
        for(let i = 0; i < arr.length; i++) {
            newArray.push(fn(arr[i]));          //call the function with name and parenthesis(or params)
        }
        return newArray;
    }
        const lenArray = mapForEach(strArray, function(item) {
        return item.length;
        });
        // prints [ 10, 6, 3, 4, 1 ]
        console.log(lenArray);

10. If we don't return anything from a function then 'undefined' is returned automatically

11. Every functions has its own 'this' and 'arguements' keyword by default.
    this -> refers to the function/object itself
    arguements -> an object that contains all the arguements passed to the function in key-value form

12. if we want to access the element from event listener, we can not use arrow functins as arrow functions does not have a 'this' binding
	document.getElementById("").addEvenetListener('click', () => {
		console.log(this)	//will NOT return the element
	})

	document.getElementById("").addEvenetListener('click', () => {
		console.log(this)	//will return the element
	})
